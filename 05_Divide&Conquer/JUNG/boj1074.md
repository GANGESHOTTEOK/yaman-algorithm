
## [Z](https://www.acmicpc.net/problem/1074)
---

### 문제 설명
한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.

![image](https://user-images.githubusercontent.com/49744558/148676691-d5ab9678-4aad-41a8-a659-d7c19f0125f9.png)

N > 1인 경우, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.

다음 예는 22 × 22 크기의 배열을 방문한 순서이다.

![image](https://user-images.githubusercontent.com/49744558/148676696-2a2e0f99-e77f-4211-9da9-fed4b7780117.png)

아~ 전형적인 분할 정복 문제이구나!

---

### 문제 접근
근데 조건 보면 N <= 15니까 2^15 = 3만 정도 되니까 이중 리스트 잡아서 풀면 안되겠다 생각했다.  
그래서 리스트 선언 안하고 count로 지금 내가 있는 곳이 몇 번째 칸인지 일일이 세서 (r,c)가 나오면 출력해주기로 했다.  
근데 그렇게 하니까 시간초과가 떠서 당황했다.  
해결 방법은 아래 소스코드에서 설명해준다.  

---

### 문제 풀이
전체 소스 코드이다.
```
N, r, c = map(int, input().split())

# 몇 번째 칸인지 세는 count이다.
count = 0

def get_order(x, y, size):
    global count
    
    # 해당 좌표 (x,y)가 찾고자 하는 좌표 (r,c)이면 count출력하고 프로그램 종료.
    if x == r and y == c:
        print(count)
        exit(0)
    
    # 재귀함수 종료 조건이다.
    # size가 1이면 한 칸이다. 그래서 count를 1 증가시켜준다.
    if size == 1:
        count += 1
        return
    
    # 이거 없으면 시간초과 뜨더라.
    # 일일이 재귀함수 호출하지 말고 내가 호출하고자 하는 함수가 확인하는 좌표안에 (r,c)가 없으면
    # 그냥 해당 영역 칸 개수만큼 count 증가시켜주고
    # 그냥 다음 함수 부르자! 이 아이디어다
    if not (x <= r < x + size and y <= c < y + size):
        count += size ** 2
        return
    
    # 재귀적으로 영역 분할 하는 부분이다.
    # 계속 영역을 4개로 쪼개준다.
    N = size // 2
    get_order(x  , y  , N)
    get_order(x  , y+N, N)
    get_order(x+N, y  , N)
    get_order(x+N, y+N, N)


get_order(0, 0, 2 ** N)
```
---

### 결과 및 한줄평
결과는 성공적이다.
---
