## 분할 정복
분할 정복 알고리즘은 다중 분기 재귀를 기반으로 하는 알고리즘 디자인 패러다임이다.  
  
분할 정복 알고리즘은 직접 해결할 수 있을 정도로 간단한 문제가 될 때까지 문제를 재귀적으로 쪼개나간 다음, 그 하위 문제의 결과들을 조합하여 원래 문제의 결과로 만들어 낸다.  
즉, 분할 정복 알고리즘은 최적 부분 구조 문제를 풀이하는 기법이다.

----

최적 부분 구조(Optimal Substructure) 문제를 풀이하는 알고리즘들로 다이나믹 프로그래밍(Dynamic programming), 그리디 알고리(Greedy algorithm), 분할 정복(Divide and conquer)이 있다.   
이 알고리즘들의 차이점은 다음과 같다.  

1. 다이나믹 프로그래밍은 최적 부분 구조와 중복된 하위 문제들(Overlapping Subproblems)로 이루어진 문제를 해결할 수 있다. 즉, 다이나믹 프로그래밍 알고리즘은 문제를 각각의 작은 문제들로 나누어 해결한 결과를 저장해 두었다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘이다. 여기서 '해결한 결과를 저장'한다는 점에 주목할 필요가 있는데, 이는 하위 문제들이 중복되기 때문에 가능한 기법이다. 대표적인 다이나믹 프로그래밍 알고리즘 문제로 '피보나치 수열 문제'를 들 수 있다.
2. 그리디 알고리즘은 최적 부분 구조와 탐욕 선택 속성(Greedy Choice Property)으로 이루어진 문제를 해결할 수 있다. 즉, 항상 그 순간에 최적이라고 생각되는 것을 선택하면서 풀이해 나간다.
3. 최적 부분 구조로 이루어져 있지만 중복된 하위 문제들로 이루어져 있지 않은 문제는 분할 정복 알고리즘으로 해결할 수 있다. 대표적인 분할 정복 알고리즘으로 '병합 정렬'이 있다. 병합 정렬은 존 폰 노이만(John von Neumann)이 1945년에 고안한 정렬 알고리즘으로, 분할 정복 알고리즘을 매우 잘 보여주는 알고리즘이다. 지금부터 병합 정렬 알고리즘으로 분할 정복 알고리즘을 설명하도록 하겠다.

![image](https://user-images.githubusercontent.com/49744558/148671581-b08a73f7-6363-4ce7-98b4-f0d436611793.png)

분할 정복 알고리즘은 최선과 최악 모두 O(nlogn)으로 일정한 알고리즘이며, 대부분의 경우 퀵 정렬보다는 느리지만 일정한 실행 속도 뿐만 아니라 안정 정렬(stable sort)이므로 상용 라이브러리에 많이 쓰이고 있다.  
위 그림에서 우리는 분할 정복으로 일정하게 정렬이 이루어지는 병합 정렬의 특징을 잘 파악할 수 있다.  
[38, 27, 43, 3, 9, 82, 10]의 배열은 [38, 27, 43, 3]과 [9, 82, 10] 두 부분으로 분할되고, 다시 [38, 27], [43, 3], [9, 82], [10] 네 부분으로 분할하는 방식으로 각각 더 이상 쪼갤 수 없을 때까지 계속해서 분할, 즉 [38], [27], [43], [3], [9], [82], [10]이 될 때까지 분할하고, 분할이 끝나면 다시 조합하면서 정렬한다. 조합하면서 정렬하는 과정은 다음과 같다.  
[27, 38], [3, 43], [9], [10, 82]  
[3, 27, 38, 43], [9, 10, 82]  
[3, 9, 10, 27, 38, 43, 82]  
위와 같은 과정을 통해서, 최종적으로 정렬된 배열을 얻을 수 있다.  

다음은 파이썬으로 작성한 병합 정렬 알고리즘 소스 코드이다.
```
array = [38, 27, 43, 3, 9, 82, 10]

def merge_sort(arr):
    # 더 이상 쪼갤 수 없으면, 즉 원소의 개수가 1개이면 
    if len(arr) < 2:
        return arr
    
    # 중간지점을 기준으로 배열을 2개로 쪼갠다 (divide)
    mid = len(arr) // 2
    low_arr = merge_sort(arr[:mid])
    high_arr = merge_sort(arr[mid:])
    
    # 쪼개어진 두 배열을 병합한다 (conquer, combine)
    # low_arr와 high_arr의 두 원소를 비교해 나가면서
    # 더 작은 원소를 merged_arr에 추가한다.
    merged_arr = []
    l = h = 0
    while l < len(low_arr) and h < len(high_arr):
        if low_arr[l] < high_arr[h]:
            merged_arr.append(low_arr[l])
            l += 1
        else:
            merged_arr.append(high_arr[h])
            h += 1

    merged_arr += low_arr[l:]
    merged_arr += high_arr[h:]
    return merged_arr

print(merge_sort(array))
```

병합 정렬 알고리즘의 과정을 보면 배열[38, 27, 43, 3, 9, 82, 10]을 정렬하기 위해서 배열[38, 27, 43, 3]과 [9, 82, 10]으로 분할(divide)하고, 각각의 배열을 정렬(conquer)한 다음 병합(combine)하였다.
즉 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우인 최적 부분 구조이다.  
하지만 부분 문제들이 중복되지는 않는다.  
따라서 병합 정렬 알고리즘은 분할 정복 알고리즘이다.  

---
분할 정복과 다이나믹 프로그래밍은 둘 다 최적 부분 구조의 문제에 적용할 수 있다는 점에서 비슷하고 또 헷갈리는 경우가 많다. 하지만 두 알고리즘은 하위 문제가 중복되는지의 여부로 구분할 수 있다. 분할 정복은 최적 부분 구조이지만 하위 문제들이 중복되지 않을 때 적용할 수 있고, 다이나믹 프로그래밍은 최적 부분 구조이면서 하위 문제들이 중복될 때 적용할 수 있다. 이 둘의 차이점에 대해서 알아보는 것은 분할 정복 알고리즘을 명확히 이해하는데 도움이 되기 때문에, 다이나믹 프로그래밍 기법으로 해결할 수 있는 대표적인 문제인 '피보나치 수열'을 통하여 다이나믹 프로그래밍에 대하여 알아보자.

아래는 피보나치 수열을 구하는 순서도이다.
![image](https://user-images.githubusercontent.com/49744558/148672662-8aefe97b-c3a6-4fd9-89a4-06bf522173c3.png)
위의 그림을 보면 알 수 있듯이, 7번째 피보나치 수열은 6번째 피보나치 수열과 5번째 피보나치 수열을 알아야 한다. 또한 6번째 피보나치 수열은 5번째 피보나치 수열과 4번째 피보나치 수열을 알아야하며, 5번째 피보나치 수열은 4번째 피보나치 수열과 3번째 피보나치 수열을 알아야 한다. 즉 7번째 피보나치 수열을 구하는 문제는 하위 문제인 6번째 피보나치 수열을 구하는 문제와 5번째 피보나치 수열을 구하는 문제로 분할할 수 있다. 즉, 최적 부분 구조이다. 또한 자세히 보면 각각의 부분 문제들이 서로 중복되는 사실을 알 수 있다. 즉 중복된 하위 문제들로 이루어져 있으므로 이미 해결한 결과를 저장해 두었다가 중복된 하위 문제가 등장하면 저장한 결과를 꺼내서 사용하는 방식인 다이나믹 프로그래밍 기법을 사용할 수 있다.


## [별 찍기 - 10](https://www.acmicpc.net/problem/2447)
---

### 문제 설명
재귀적인 패턴으로 별을 찍는 문제이다.  
어떤 정수 k에 대해 N=3^k이고 1 ≤ k < 8이다.  

---

### 문제 접근

N = 3 일때 다음과 같다.  

![image](https://user-images.githubusercontent.com/49744558/148676241-2266de7d-8201-4104-87f3-03fdc7758d08.png)

N = 3^i 일 때, N = 3^(i-1)의 패턴이 반복적으로 그려지는 패턴이다.  

![image](https://user-images.githubusercontent.com/49744558/148676261-304572d2-ff1c-443f-a094-7e46376c12dc.png)

---

### 문제 풀이
전체 소스 코드이다.  

```
N = int(input())
# N x N 이중 리스트를 선언한다.
# 0은 공백, 1은 별로 취급한다.
stars = [[0 for _ in range(N)] for _ in range(N)]

def draw_stars(stars, x, y, N):
    # N = 3이면 1과 0을 기록한다.
    if N == 3:
        for i in range(x, x+N):
            for j in range(y, y+N):
                # 정중앙은 공백이다.
                if i % 3 == 1 and j % 3 == 1:
                    stars[i][j] = 0
                # 그 외에는 별이다.
                else:
                    stars[i][j] = 1
        return
    
    # 전체 이중 리스트를 9등분 한다.
    size = N // 3
    for i in range(3):
        for j in range(3):
            # 9등분된 리스트 중에서 정중앙은 아무것도 안한다.
            # 즉 0 (공백)을 유지한다.
            if i % 3 == 1 and j % 3 == 1:
                continue
            # 그 외에는 재귀적으로 0과 1을 찍어준다.
            else:
                draw_stars(stars, x + size * i, y + size * j, size)


draw_stars(stars, 0, 0, N)
for i in range(N):
    for j in range(N):
        # 0이면 공백을 출력하고, 1이면 별을 출력한다.
        print(' ' if stars[i][j] == 0 else '*', end="")
    print()
```

---

### 결과 및 한줄평
결과는 성공적이다.  
 
---


## [Z](https://www.acmicpc.net/problem/1074)
---

### 문제 설명
한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.

![image](https://user-images.githubusercontent.com/49744558/148676691-d5ab9678-4aad-41a8-a659-d7c19f0125f9.png)

N > 1인 경우, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.

다음 예는 22 × 22 크기의 배열을 방문한 순서이다.

![image](https://user-images.githubusercontent.com/49744558/148676696-2a2e0f99-e77f-4211-9da9-fed4b7780117.png)

아~ 전형적인 분할 정복 문제이구나!

---

### 문제 접근
근데 조건 보면 N <= 15니까 2^15 = 3만 정도 되니까 이중 리스트 잡아서 풀면 안되겠다 생각했다.  
그래서 리스트 선언 안하고 count로 지금 내가 있는 곳이 몇 번째 칸인지 일일이 세서 (r,c)가 나오면 출력해주기로 했다.  
근데 그렇게 하니까 시간초과가 떠서 당황했다.  
해결 방법은 아래 소스코드에서 설명해준다.  

---

### 문제 풀이
전체 소스 코드이다.
```
N, r, c = map(int, input().split())

# 몇 번째 칸인지 세는 count이다.
count = 0

def get_order(x, y, size):
    global count
    
    # 해당 좌표 (x,y)가 찾고자 하는 좌표 (r,c)이면 count출력하고 프로그램 종료.
    if x == r and y == c:
        print(count)
        exit(0)
    
    # 재귀함수 종료 조건이다.
    # size가 1이면 한 칸이다. 그래서 count를 1 증가시켜준다.
    if size == 1:
        count += 1
        return
    
    # 이거 없으면 시간초과 뜨더라.
    # 일일이 재귀함수 호출하지 말고 내가 호출하고자 하는 함수가 확인하는 좌표안에 (r,c)가 없으면
    # 그냥 해당 영역 칸 개수만큼 count 증가시켜주고
    # 그냥 다음 함수 부르자! 이 아이디어다
    if not (x <= r < x + size and y <= c < y + size):
        count += size ** 2
        return
    
    # 재귀적으로 영역 분할 하는 부분이다.
    # 계속 영역을 4개로 쪼개준다.
    N = size // 2
    get_order(x  , y  , N)
    get_order(x  , y+N, N)
    get_order(x+N, y  , N)
    get_order(x+N, y+N, N)


get_order(0, 0, 2 ** N)
```
---

### 결과 및 한줄평
결과는 성공적이다.
---












