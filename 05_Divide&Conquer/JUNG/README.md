## 분할 정복
분할 정복 알고리즘은 다중 분기 재귀를 기반으로 하는 알고리즘 디자인 패러다임이다.  
  
분할 정복 알고리즘은 직접 해결할 수 있을 정도로 간단한 문제가 될 때까지 문제를 재귀적으로 쪼개나간 다음, 그 하위 문제의 결과들을 조합하여 원래 문제의 결과로 만들어 낸다.  
즉, 분할 정복 알고리즘은 최적 부분 구조 문제를 풀이하는 기법이다.

----

최적 부분 구조(Optimal Substructure) 문제를 풀이하는 알고리즘들로 다이나믹 프로그래밍(Dynamic programming), 그리디 알고리(Greedy algorithm), 분할 정복(Divide and conquer)이 있다.   
이 알고리즘들의 차이점은 다음과 같다.  

1. 다이나믹 프로그래밍은 최적 부분 구조와 중복된 하위 문제들(Overlapping Subproblems)로 이루어진 문제를 해결할 수 있다. 즉, 다이나믹 프로그래밍 알고리즘은 문제를 각각의 작은 문제들로 나누어 해결한 결과를 저장해 두었다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘이다. 여기서 '해결한 결과를 저장'한다는 점에 주목할 필요가 있는데, 이는 하위 문제들이 중복되기 때문에 가능한 기법이다. 대표적인 다이나믹 프로그래밍 알고리즘 문제로 '피보나치 수열 문제'를 들 수 있다.
2. 그리디 알고리즘은 최적 부분 구조와 탐욕 선택 속성(Greedy Choice Property)으로 이루어진 문제를 해결할 수 있다. 즉, 항상 그 순간에 최적이라고 생각되는 것을 선택하면서 풀이해 나간다.
3. 최적 부분 구조로 이루어져 있지만 중복된 하위 문제들로 이루어져 있지 않은 문제는 분할 정복 알고리즘으로 해결할 수 있다. 대표적인 분할 정복 알고리즘으로 '병합 정렬'이 있다. 병합 정렬은 존 폰 노이만(John von Neumann)이 1945년에 고안한 정렬 알고리즘으로, 분할 정복 알고리즘을 매우 잘 보여주는 알고리즘이다. 지금부터 병합 정렬 알고리즘으로 분할 정복 알고리즘을 설명하도록 하겠다.

![image](https://user-images.githubusercontent.com/49744558/148671581-b08a73f7-6363-4ce7-98b4-f0d436611793.png)

분할 정복 알고리즘은 최선과 최악 모두 O(nlogn)으로 일정한 알고리즘이며, 대부분의 경우 퀵 정렬보다는 느리지만 일정한 실행 속도 뿐만 아니라 안정 정렬(stable sort)이므로 상용 라이브러리에 많이 쓰이고 있다.  
위 그림에서 우리는 분할 정복으로 일정하게 정렬이 이루어지는 병합 정렬의 특징을 잘 파악할 수 있다.  
[38, 27, 43, 3, 9, 82, 10]의 배열은 [38, 27, 43, 3]과 [9, 82, 10] 두 부분으로 분할되고, 다시 [38, 27], [43, 3], [9, 82], [10] 네 부분으로 분할하는 방식으로 각각 더 이상 쪼갤 수 없을 때까지 계속해서 분할, 즉 [38], [27], [43], [3], [9], [82], [10]이 될 때까지 분할하고, 분할이 끝나면 다시 조합하면서 정렬한다. 조합하면서 정렬하는 과정은 다음과 같다.  
[27, 38], [3, 43], [9], [10, 82]  
[3, 27, 38, 43], [9, 10, 82]  
[3, 9, 10, 27, 38, 43, 82]  
위와 같은 과정을 통해서, 최종적으로 정렬된 배열을 얻을 수 있다.  

다음은 파이썬으로 작성한 병합 정렬 알고리즘 소스 코드이다.
```
array = [38, 27, 43, 3, 9, 82, 10]

def merge_sort(arr):
    # 더 이상 쪼갤 수 없으면, 즉 원소의 개수가 1개이면 
    if len(arr) < 2:
        return arr
    
    # 중간지점을 기준으로 배열을 2개로 쪼갠다 (divide)
    mid = len(arr) // 2
    low_arr = merge_sort(arr[:mid])
    high_arr = merge_sort(arr[mid:])
    
    # 쪼개어진 두 배열을 병합한다 (conquer, combine)
    # low_arr와 high_arr의 두 원소를 비교해 나가면서
    # 더 작은 원소를 merged_arr에 추가한다.
    merged_arr = []
    l = h = 0
    while l < len(low_arr) and h < len(high_arr):
        if low_arr[l] < high_arr[h]:
            merged_arr.append(low_arr[l])
            l += 1
        else:
            merged_arr.append(high_arr[h])
            h += 1

    merged_arr += low_arr[l:]
    merged_arr += high_arr[h:]
    return merged_arr

print(merge_sort(array))
```

병합 정렬 알고리즘의 과정을 보면 배열[38, 27, 43, 3, 9, 82, 10]을 정렬하기 위해서 배열[38, 27, 43, 3]과 [9, 82, 10]으로 분할(divide)하고, 각각의 배열을 정렬(conquer)한 다음 병합(combine)하였다.
즉 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우인 최적 부분 구조이다.  
하지만 부분 문제들이 중복되지는 않는다.  
따라서 병합 정렬 알고리즘은 분할 정복 알고리즘이다.  

---
분할 정복과 다이나믹 프로그래밍은 둘 다 최적 부분 구조의 문제에 적용할 수 있다는 점에서 비슷하고 또 헷갈리는 경우가 많다. 하지만 두 알고리즘은 하위 문제가 중복되는지의 여부로 구분할 수 있다. 분할 정복은 최적 부분 구조이지만 하위 문제들이 중복되지 않을 때 적용할 수 있고, 다이나믹 프로그래밍은 최적 부분 구조이면서 하위 문제들이 중복될 때 적용할 수 있다. 이 둘의 차이점에 대해서 알아보는 것은 분할 정복 알고리즘을 명확히 이해하는데 도움이 되기 때문에, 다이나믹 프로그래밍 기법으로 해결할 수 있는 대표적인 문제인 '피보나치 수열'을 통하여 다이나믹 프로그래밍에 대하여 알아보자.

아래는 피보나치 수열을 구하는 순서도이다.
![image](https://user-images.githubusercontent.com/49744558/148672662-8aefe97b-c3a6-4fd9-89a4-06bf522173c3.png)
위의 그림을 보면 알 수 있듯이, 7번째 피보나치 수열은 6번째 피보나치 수열과 5번째 피보나치 수열을 알아야 한다. 또한 6번째 피보나치 수열은 5번째 피보나치 수열과 4번째 피보나치 수열을 알아야하며, 5번째 피보나치 수열은 4번째 피보나치 수열과 3번째 피보나치 수열을 알아야 한다. 즉 7번째 피보나치 수열을 구하는 문제는 하위 문제인 6번째 피보나치 수열을 구하는 문제와 5번째 피보나치 수열을 구하는 문제로 분할할 수 있다. 즉, 최적 부분 구조이다. 또한 자세히 보면 각각의 부분 문제들이 서로 중복되는 사실을 알 수 있다. 즉 중복된 하위 문제들로 이루어져 있으므로 이미 해결한 결과를 저장해 두었다가 중복된 하위 문제가 등장하면 저장한 결과를 꺼내서 사용하는 방식인 다이나믹 프로그래밍 기법을 사용할 수 있다.

아래는 다익스트라 알고리즘 












